#!/usr/bin/ruby -w
# requires you to have previously run:
# gem install dbi

require 'rubygems'
require 'dbi'
require 'trollop'

# from Rails
class Object
  def blank?
    respond_to?(:empty?) ? empty? : !self
  end
  
  def prettify
    to_s
  end
end

# prettify by Yahuda Katz
# http://stackoverflow.com/questions/1077346/ruby-round-float-to-int-if-whole-number
class Float
  def prettify
    to_i == self ? to_i : self
  end
end


opts = Trollop::options do
  version "Schema Sleuth 2.0 (c) 2010-2011 Gary S. Weaver"
  banner <<-EOS
  
  Connects to and spiders a database, outputting related records based on the column name and value provided.

  Examples:
  
  
  MySQL:
  
  ssleuth -r DBI:Mysql:TESTDB:localhost -u jdoe -p secret -c user_id -e 1234
  
  Oracle:
  
  ssleuth -r DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD -u jdoe -p secret -c user_id -e 1234
  
  Custom:
  
  ssleuth -r DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD -u jdoe -p secret -c user_id -e 1234 -t "select TABLE_NAME from ALL_ALL_TABLES" -n "select column_name FROM all_tab_cols where table_name = ?"

  
  Usage:
  
         ssleuth [options]
         
  where [options] are:
  
  EOS
  opt :driver_url, "DBI driver URL. Be sure to add .WORLD after the SID for Oracle. e.g. DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD", :short => 'r', :type => String
  opt :user, "database username. e.g. jdoe", :short => 'u', :type => String
  opt :password, "database password. e.g. secret", :short => 'p', :type => String
  opt :column_name, "column name. e.g. user_id", :short => 'c', :type => String
  opt :value, "column value. e.g. 1234", :short => 'e', :type => String
  opt :table_names_query, "SQL query to use to get full listing of tables. e.g. \"select TABLE_NAME from ALL_ALL_TABLES\"", :short => 't', :type => String
  opt :column_names_query, "SQL query to use to get column names for a table. Substitute $TABLE_NAME for the table name. e.g. \"select column_name FROM all_tab_cols where table_name = '$TABLE_NAME'\"", :short => 'n', :type => String
  opt :debug, "outputs debugging information", :short => 'd', :default => false
end

Trollop::die :driver_url, "must provide a DBI driver URL. Be sure to add .WORLD after the SID for Oracle. e.g. DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD" unless opts[:driver_url]
Trollop::die :user, "must provide a database username. e.g. jdoe" unless opts[:user]
Trollop::die :password, "must provide a atabase password. e.g. secret" unless opts[:password]
Trollop::die :column_name, "must provide a column name. e.g. user_id" unless opts[:column_name]
Trollop::die :value, "must provide a column value. e.g. 1234" unless opts[:value]

puts "DBI version: #{DBI::VERSION}" if opts[:debug]

if opts[:driver_url].upcase.match(/^DBI:OCI8/)
  # oracle
  opts[:table_names_query] = 'select TABLE_NAME from ALL_ALL_TABLES' if opts[:table_names_query].blank?
  opts[:column_names_query] = 'select column_name FROM all_tab_cols where table_name = \'$TABLE_NAME\'' if opts[:column_names_query].blank?
else
  Trollop::die :table_names_query, "Please specify a table names query for this database." if opts[:table_names_query].blank?
  Trollop::die :column_names_query, "Please specify a column names query for this database." if opts[:column_names_query].blank?
end

if opts[:debug]
  puts "driver_url=#{opts[:driver_url]}"
  puts "user=#{opts[:user]}"
  puts "password=#{opts[:password]}"
  puts "column_name=#{opts[:column_name]}"
  puts "value=#{opts[:value]}"
  puts "table_names_query=#{opts[:table_names_query]}"
  puts "column_names_query=#{opts[:column_names_query]}"
  puts "debug=#{opts[:debug]}"
end

def sleuth(dbh, table_names, opts, excluded_data_pointers, stack)  
  if stack.size > 5
    stack.pop
    return
  end
  
  table_names.each do |this_table_name|
    specific_column_names_query = String.new(opts[:column_names_query])
    specific_column_names_query['$TABLE_NAME'] = this_table_name
    last_query = specific_column_names_query
    begin
      if opts[:debug]
        puts specific_column_names_query 
      end
      column_names_rows = dbh.select_all(specific_column_names_query)
      column_names_rows.each do |column_name_row|
        this_column_name = column_name_row[0]
        if this_column_name.upcase.eql? opts[:column_name].upcase
          count_query = "select count(#{opts[:column_name]}) from #{this_table_name} where #{opts[:column_name]}=?"
          prepared_count_query = dbh.prepare(count_query)
          last_query = count_query
          count_row = dbh.select_one(count_query, opts[:value])
          if count_row[0] && count_row[0].to_i > 1000
            if opts[:debug]
              puts "skipping #{this_table_name}: (found #{count_row[0].to_i} rows matching, which exceeded maximum row count of 1000.)"
              puts ''
              puts ''
            end
          else
            data_query = "select * from #{this_table_name} where #{opts[:column_name]}=?"
            prepared_data_query = dbh.prepare(data_query)
            last_query = data_query
            clue_rows = dbh.select_all(data_query, opts[:value])
            
            if (clue_rows.size > 0)
              if opts[:debug]
                sorted_stack = stack.sort.join("\n")
                puts "Stack:\n#{sorted_stack}"
                puts ''
                puts ''
              end
              
              puts "#{this_table_name}"
              puts ''
              puts column_names_rows.collect {|column_names_row| column_names_row[0] }.join ', '
              puts '------------'
          
              clue_rows.each do |clue_row|
                puts clue_row.collect{|x| x.prettify }.join ', '
              end
              puts ''
              puts ''
          
              clue_rows.each_with_index do |clue_row, clue_row_index|
                clue_row.each_with_index do |clue_row_column_value, clue_row_column_value_index|
                  if clue_row_column_value && clue_row_column_value.to_s.size > 0
                    clue_row_column_name = column_names_rows[clue_row_column_value_index][0]
                    #data_pointer = "#{this_table_name}:#{clue_row.join(', ')}"
                    data_pointer = "#{this_table_name}.#{clue_row_column_name}"
                    if !(excluded_data_pointers.include? data_pointer)
                      if opts[:debug]
                        sorted_list = excluded_data_pointers.sort.join("\n")
                        puts "#{data_pointer}\nnot found in:\n#{sorted_list}"
                        puts "Following #{data_pointer}"
                      end
                      
                      excluded_data_pointers << data_pointer
                      stack << "#{this_table_name}.#{clue_row_column_name} = '#{clue_row_column_value}'"
                  
                      sleuth(dbh, table_names, opts, excluded_data_pointers, stack)
                    end
                  end
                end
              end
            end
          end
        end
      end
      
    rescue Exception => e
      puts "#{e.message}"
      eol = "\n"
      puts "#{e.backtrace.join(eol)}"
    end
  end
  
  stack.pop
  return
end

table_names = []
begin
  dbh = DBI.connect(opts[:driver_url], opts[:user], opts[:password])

  if opts[:debug]
    # get server version string and display it
    row = dbh.select_one('select version from v$instance')
    puts "Server version: #{row[0]}"
    puts ''
    puts opts[:table_names_query]
  end
  
  table_names_rows = dbh.select_all(opts[:table_names_query])
  puts "Tables: #{table_names_rows.inspect}" if opts[:debug]
  
  table_names_rows.each do |table_name_row|
    table_names << table_name_row[0]
  end
  
  sleuth(dbh, table_names, opts, [], [])
  
rescue DBI::DatabaseError => e
  puts "An error occurred"
  puts "Error code: #{e.err}"
  puts "Error message: #{e.errstr}"
ensure
  # disconnect from server
  dbh.disconnect if dbh
end

