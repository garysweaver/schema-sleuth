#!/usr/bin/ruby -w
# requires you to have previously run:
# gem install dbi

require 'rubygems'
require 'dbi'
require 'trollop'

# from Rails
class Object
  def blank?
    respond_to?(:empty?) ? empty? : !self
  end
  
  def prettify
    to_s
  end
  
  def sql_valuify
    if nil?
      "NULL"
    else
      "'" + to_s + "'"
    end
  end
end

# prettify by Yahuda Katz
# http://stackoverflow.com/questions/1077346/ruby-round-float-to-int-if-whole-number
class Float
  def prettify
    to_i == self ? to_i : self
  end
end

module SchemaSleuth
  class TableData
    attr_accessor :name, :columns, :row_hash
  end
end

opts = Trollop::options do
  version "Schema Sleuth 2.0 (c) 2010-2011 Gary S. Weaver"
  banner <<-EOS
  
  Connects to and spiders a database, outputting related records based on the column name and value provided.

  Examples:
  
  
  MySQL:
  
  ssleuth -r DBI:Mysql:TESTDB:localhost -u jdoe -p secret -c user_id -e 1234
  
  Oracle:
  
  ssleuth -r DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD -u jdoe -p secret -c user_id -e 1234
  
  Custom:
  
  ssleuth -r DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD -u jdoe -p secret -c user_id -e 1234 -t "select TABLE_NAME from ALL_ALL_TABLES" -n "select column_name FROM all_tab_cols where table_name = ?"

  
  Usage:
  
         ssleuth [options]
         
  where [options] are:
  
  EOS
  opt :driver_url, "DBI driver URL. Be sure to add .WORLD after the SID for Oracle. e.g. DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD", :short => 'r', :type => String
  opt :user, "database username. e.g. jdoe", :short => 'u', :type => String
  opt :password, "database password. e.g. secret", :short => 'p', :type => String
  opt :column_name, "column name. e.g. user_id", :short => 'c', :type => String
  opt :value, "column value. e.g. 1234", :short => 'e', :type => String
  opt :table_names_query, "SQL query to use to get full listing of tables. e.g. \"select TABLE_NAME from ALL_ALL_TABLES\"", :short => 't', :type => String
  opt :column_names_query, "SQL query to use to get column names for a table. Substitute $TABLE_NAME for the table name. e.g. \"select column_name FROM all_tab_cols where table_name = '$TABLE_NAME'\"", :short => 'n', :type => String
  opt :generate_inserts, "output as insert statements", :short => 'i', :default => false
  opt :debug, "outputs debugging information", :short => 'd', :default => false
end

Trollop::die :driver_url, "must provide a DBI driver URL. Be sure to add .WORLD after the SID for Oracle. e.g. DBI:OCI8://db.acme.org:1234/ACMETEST.WORLD" unless opts[:driver_url]
Trollop::die :user, "must provide a database username. e.g. jdoe" unless opts[:user]
Trollop::die :password, "must provide a atabase password. e.g. secret" unless opts[:password]
Trollop::die :column_name, "must provide a column name. e.g. user_id" unless opts[:column_name]
Trollop::die :value, "must provide a column value. e.g. 1234" unless opts[:value]

puts "DBI version: #{DBI::VERSION}" if opts[:debug]

if opts[:driver_url].upcase.match(/^DBI:OCI8/)
  # oracle
  opts[:table_names_query] = 'select TABLE_NAME from ALL_ALL_TABLES' if opts[:table_names_query].blank?
  opts[:column_names_query] = 'select column_name FROM all_tab_cols where table_name = \'$TABLE_NAME\'' if opts[:column_names_query].blank?
else
  Trollop::die :table_names_query, "Please specify a table names query for this database." if opts[:table_names_query].blank?
  Trollop::die :column_names_query, "Please specify a column names query for this database." if opts[:column_names_query].blank?
end

if opts[:debug]
  puts "driver_url=#{opts[:driver_url]}"
  puts "user=#{opts[:user]}"
  puts "password=#{opts[:password]}"
  puts "column_name=#{opts[:column_name]}"
  puts "value=#{opts[:value]}"
  puts "table_names_query=#{opts[:table_names_query]}"
  puts "column_names_query=#{opts[:column_names_query]}"
  puts "debug=#{opts[:debug]}"
end

def sleuth(dbh, store, table_names, column_name, value, opts, excluded_data_pointers, stack)  
  if stack.size > 5
    if opts[:debug]
      puts "Stack size exceeded. Skipping..."
    else
      print 'O'
      STDOUT.flush
    end
    stack.pop
    return
  end
  
  table_names.each do |this_table_name|
    begin
      if !store[this_table_name]
        store[this_table_name] = SchemaSleuth::TableData.new 
        store[this_table_name].name = this_table_name
        puts "Table: #{this_table_name}" if opts[:debug]
        
        specific_column_names_query = String.new(opts[:column_names_query])
        specific_column_names_query['$TABLE_NAME'] = this_table_name
        last_query = specific_column_names_query
        if opts[:debug]
          puts specific_column_names_query 
        end
        column_names_rows = dbh.select_all(specific_column_names_query)
        
        store[this_table_name].columns = column_names_rows.collect {|column_names_row| column_names_row[0] }
        puts "Columns: #{store[this_table_name].columns.join(', ')}" if opts[:debug]
        store[this_table_name].row_hash = {}
      end
      
      store_table = store[this_table_name]
      
      store_table.columns.each do |this_column_name|
        if this_column_name.upcase.eql? column_name.upcase
          count_query = "select count(#{column_name}) from #{this_table_name} where #{column_name}=?"
          prepared_count_query = dbh.prepare(count_query)
          last_query = count_query
          count_row = dbh.select_one(count_query, value)
          if count_row[0] && count_row[0].to_i > 1000
            if opts[:debug]
              puts "skipping #{this_table_name}: (found #{count_row[0].to_i} rows matching, which exceeded maximum row count of 1000.)"
              puts ''
              puts ''
            else
              print 'M'
              STDOUT.flush
            end
          else
            data_query = "select * from #{this_table_name} where #{column_name}=?"
            prepared_data_query = dbh.prepare(data_query)
            last_query = data_query
            clue_rows = dbh.select_all(data_query, value)
            
            if (clue_rows.size > 0)
              if opts[:debug]
                sorted_stack = stack.sort.join("\n")
                puts "Stack:\n#{sorted_stack}"
                puts ''
                puts ''
              end
              
              clue_rows.each do |clue_row|
                clue_row.collect{|x| x.prettify }
                row_data = clue_row.collect{|x| x.prettify.sql_valuify }
                unique_key = row_data.join(', ')
                store_table.row_hash[unique_key] = row_data
                if opts[:debug]
                  puts "Row: #{unique_key}"
                else
                  print '.'
                  STDOUT.flush
                end
              end
              
              clue_rows.each_with_index do |clue_row, clue_row_index|
                clue_row.each_with_index do |clue_row_column_value, clue_row_column_value_index|
                  if clue_row_column_value && clue_row_column_value.to_s.size > 0
                    clue_row_column_name = store_table.columns[clue_row_column_value_index]
                    #data_pointer = "#{this_table_name}:#{clue_row.join(', ')}"
                    data_pointer = "#{this_table_name}.#{clue_row_column_name}"
                    if !(excluded_data_pointers.include? data_pointer)
                      if opts[:debug]
                        sorted_list = excluded_data_pointers.sort.join("\n")
                        puts "#{data_pointer}\nnot found in:\n#{sorted_list}"
                        puts "Following #{data_pointer}"
                      end
                      
                      excluded_data_pointers << data_pointer
                      stack << "#{this_table_name}.#{clue_row_column_name} = '#{clue_row_column_value}'"
                  
                      sleuth(dbh, store, table_names, clue_row_column_name, clue_row_column_value, opts, excluded_data_pointers, stack)
                    end
                  end
                end
              end
            end
          end
        end
      end
      
    rescue Exception => e
      puts "#{e.message}"
      eol = "\n"
      puts "#{e.backtrace.join(eol)}"
    end
  end
  
  stack.pop
  return
end

def output(store, opts)
  store.keys.sort.each do |store_key|
    table = store[store_key]
    if table.row_hash && table.row_hash.size > 0
      if opts[:generate_inserts]
        table.row_hash.keys.sort.each do |row_key|
          row = table.row_hash[row_key]
          puts "   INSERT INTO #{table.name} (#{table.columns.join ', '}) VALUES (#{row.join ', '});"
        end
      else
        puts "#{table.name}"
        puts ''
        puts table.columns.join ', '
        puts '------------'

        table.row_hash.keys.sort.each do |row_key|
          row = table.row_hash[row_key]
          puts row.join ', '
        end
        puts ''
        puts ''
      end
    end
  end
end

table_names = []
begin
  dbh = DBI.connect(opts[:driver_url], opts[:user], opts[:password])

  if opts[:debug]
    # get server version string and display it
    row = dbh.select_one('select version from v$instance')
    puts "Server version: #{row[0]}"
    puts ''
    puts opts[:table_names_query]
  end
  
  table_names_rows = dbh.select_all(opts[:table_names_query])
  puts "Tables: #{table_names_rows.inspect}" if opts[:debug]
  
  table_names_rows.each do |table_name_row|
    table_names << table_name_row[0]
  end
  
  puts "Analyzing..." if opts[:debug]
  
  store = {}
  
  sleuth(dbh, store, table_names, opts[:column_name], opts[:value], opts, [], [])
  
  puts ''
  puts "Outputting..." if opts[:debug]
  
  output(store, opts)
  
rescue DBI::DatabaseError => e
  puts "An error occurred"
  puts "Error code: #{e.err}"
  puts "Error message: #{e.errstr}"
ensure
  # disconnect from server
  dbh.disconnect if dbh
end

